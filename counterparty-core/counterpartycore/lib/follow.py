import asyncio
import logging
import signal
import struct
import time

import zmq
import zmq.asyncio

from counterpartycore.lib import blocks, config, exceptions, ledger
from counterpartycore.lib.kickstart import blocks_parser, parse_block

logger = logging.getLogger(config.LOGGER_NAME)

port = 28332


def parse_mempool_transaction(db, decoded_tx):
    logger.debug("Parsing mempool transaction: %s" % decoded_tx["tx_hash"])
    now = time.time()
    transaction_events = []
    try:
        with db:
            cursor = db.cursor()
            # insert fake block
            cursor.execute(
                """INSERT INTO blocks(
                                block_index,
                                block_hash,
                                block_time) VALUES(?,?,?)""",
                (config.MEMPOOL_BLOCK_INDEX, config.MEMPOOL_BLOCK_HASH, now),
            )
            # list_tx
            cursor.execute("SELECT tx_index FROM transactions ORDER BY tx_index DESC LIMIT 1")
            mempool_tx_index = cursor.fetchone()["tx_index"]
            blocks.list_tx(
                db,
                config.MEMPOOL_BLOCK_HASH,
                config.MEMPOOL_BLOCK_INDEX,
                now,
                decoded_tx["tx_hash"],
                tx_index=mempool_tx_index,
                decoded_tx=decoded_tx,
            )
            # parse fake block
            blocks.parse_block(db, config.MEMPOOL_BLOCK_INDEX, now)
            # get messages generated by the transaction
            cursor.execute(
                """SELECT * FROM messages WHERE block_index = ?""",
                (config.MEMPOOL_BLOCK_INDEX,),
            )
            # save the events in memory
            transaction_events = cursor.fetchall()
            # we raise an exception to rollback the transaction
            raise exceptions.MempoolError("Mempool transaction parsed successfully")
    except exceptions.MempoolError:
        # save events in the mempool table
        for event in transaction_events:
            bindings = event | {"tx_hash": decoded_tx["tx_hash"]}
            cursor.execute(
                """INSERT INTO mempool VALUES(:tx_hash, :command, :category, :bindings, :timestamp, :event)""",
                bindings,
            )


def clean_transaction_events(db, tx_hash):
    cursor = db.cursor()
    cursor.execute("DELETE FROM mempool WHERE tx_hash = ?", (tx_hash,))


def clean_mempool(db):
    logger.debug("Cleaning mempool...")
    cursor = db.cursor()
    cursor.execute("SELECT * FROM mempool")
    mempool_events = cursor.fetchall()
    for event in mempool_events:
        tx = ledger.get_transaction(db, event["tx_hash"])
        if tx:
            clean_transaction_events(db, event["tx_hash"])


def parse_new_block(db, block):
    tx_index = blocks.get_next_tx_index(db)
    parse_block(db, block, block_parser=None, tx_index=tx_index)


def disconnect_block(db, block_hash):
    cursor = db.cursor()
    cursor.execute("SELECT * FROM blocks WHERE block_hash = ?", (block_hash,))
    block = cursor.fetchone()
    block_index = block["block_index"]
    blocks.rollback(db, block_index)


class BlockchainWatcher:
    def __init__(self, db):
        self.db = db
        self.loop = asyncio.get_event_loop()
        self.zmqContext = zmq.asyncio.Context()
        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)
        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)
        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, "rawblock")
        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, "rawtx")
        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, "sequence")
        self.zmqSubSocket.connect("tcp://127.0.0.1:%i" % port)
        self.decoded_tx_cache = {}
        self.block_cache = {}

    async def handle(self):
        topic, body, seq = await self.zmqSubSocket.recv_multipart()
        sequence = "Unknown"
        if len(seq) == 4:
            sequence = str(struct.unpack("<I", seq)[-1])
        logger.debug("Received message: %s %s" % (topic, sequence))

        if topic == b"rawblock":
            block = blocks_parser.BlockchainParser().deserialize_block(body.hex())
            if block["block_hash"] not in self.block_cache:
                self.block_cache[block["block_hash"]] = block
        elif topic == b"rawtx":
            # decode transactions as they come in
            tx = blocks_parser.BlockchainParser().deserialize_tx(body.hex())
            if tx["tx_hash"] not in self.decoded_tx_cache:
                self.decoded_tx_cache[tx["tx_hash"]] = tx
        elif topic == b"sequence":
            hash = body[:32].hex()
            label = chr(body[32])
            # new transaction in mempool
            if label == "A":
                # parse the transaction
                decoded_tx = self.decoded_tx_cache[hash]
                parse_mempool_transaction(self.db, decoded_tx)
            elif label == "R":
                # transaction removed from mempool for non-block inclusion reasons
                clean_transaction_events(self.db, hash)
            # new block connected
            elif label in ["C"]:
                clean_mempool(self.db)
                parse_new_block(self.db, self.block_cache[hash])
            # block disconnected (reorg)
            elif label in ["D"]:
                clean_mempool(self.db)
                disconnect_block(self.db, hash)
        # schedule ourselves to receive the next message
        if not self.paused:
            asyncio.ensure_future(self.handle())

    def start(self):
        self.loop.add_signal_handler(signal.SIGINT, self.stop)
        self.loop.create_task(self.handle())
        self.loop.run_forever()

    def stop(self):
        self.loop.stop()
        self.zmqContext.destroy()
