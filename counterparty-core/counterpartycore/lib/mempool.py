import argparse
import asyncio
import logging
import signal
import struct
import time
from multiprocessing import Process

import zmq
import zmq.asyncio

from counterpartycore import server
from counterpartycore.lib import blocks, config, database, exceptions, ledger, sentry
from counterpartycore.lib.kickstart import blocks_parser

logger = logging.getLogger(config.LOGGER_NAME)

port = 28332


def parse_mempool_transaction(db, decoded_tx):
    logger.debug("Parsing mempool transaction: %s" % decoded_tx["tx_hash"])
    now = time.time()
    transaction_events = []
    try:
        with db:
            cursor = db.cursor()
            # insert fake block
            cursor.execute(
                """INSERT INTO blocks(
                                block_index,
                                block_hash,
                                block_time) VALUES(?,?,?)""",
                (config.MEMPOOL_BLOCK_INDEX, config.MEMPOOL_BLOCK_HASH, now),
            )
            # list_tx
            cursor.execute("SELECT tx_index FROM transactions ORDER BY tx_index DESC LIMIT 1")
            mempool_tx_index = cursor.fetchone()["tx_index"]
            blocks.list_tx(
                db,
                config.MEMPOOL_BLOCK_HASH,
                config.MEMPOOL_BLOCK_INDEX,
                now,
                decoded_tx["tx_hash"],
                tx_index=mempool_tx_index,
                decoded_tx=decoded_tx,
            )
            # parse fake block
            blocks.parse_block(db, config.MEMPOOL_BLOCK_INDEX, now)
            # get messages generated by the transaction
            cursor.execute(
                """SELECT * FROM messages WHERE block_index = ?""",
                (config.MEMPOOL_BLOCK_INDEX,),
            )
            # save the events in memory
            transaction_events = cursor.fetchall()
            # we raise an exception to rollback the transaction
            raise exceptions.MempoolError("Mempool transaction parsed successfully")
    except exceptions.MempoolError:
        # save events in the mempool table
        for event in transaction_events:
            bindings = event | {"tx_hash": decoded_tx["tx_hash"]}
            cursor.execute(
                """INSERT INTO mempool VALUES(:tx_hash, :command, :category, :bindings, :timestamp, :event)""",
                bindings,
            )


def clean_transaction_events(db, tx_hash):
    cursor = db.cursor()
    cursor.execute("DELETE FROM mempool WHERE tx_hash = ?", (tx_hash,))


def clean_mempool(db):
    logger.debug("Cleaning mempool...")
    with db:
        cursor = db.cursor()
        cursor.execute("SELECT * FROM mempool")
        mempool_events = cursor.fetchall()
        for event in mempool_events:
            tx = ledger.get_transaction(db, event["tx_hash"])
            if tx:
                clean_transaction_events(db, event["tx_hash"])


class ZMQHandler:
    def __init__(self, db):
        self.db = db
        self.loop = asyncio.get_event_loop()
        self.zmqContext = zmq.asyncio.Context()
        self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)
        self.zmqSubSocket.setsockopt(zmq.RCVHWM, 0)
        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, "rawtx")
        self.zmqSubSocket.setsockopt_string(zmq.SUBSCRIBE, "sequence")
        self.zmqSubSocket.connect("tcp://127.0.0.1:%i" % port)
        self.decoded_tx_cache = {}

    async def handle(self):
        topic, body, seq = await self.zmqSubSocket.recv_multipart()
        sequence = "Unknown"
        if len(seq) == 4:
            sequence = str(struct.unpack("<I", seq)[-1])
        logger.debug("Received message: %s %s" % (topic, sequence))
        if topic == b"rawtx":
            # decode transactions as they come in
            tx = blocks_parser.BlockchainParser().deserialize_tx(body.hex())
            if tx["tx_hash"] not in self.decoded_tx_cache:
                self.decoded_tx_cache[tx["tx_hash"]] = tx
        elif topic == b"sequence":
            hash = body[:32].hex()
            label = chr(body[32])
            # new transaction in mempool
            if label == "A":
                # parse the transaction
                decoded_tx = self.decoded_tx_cache.get(hash)
                if decoded_tx:
                    parse_mempool_transaction(self.db, decoded_tx)
            elif label == "R":
                # transaction removed from mempool for non-block inclusion reasons
                clean_transaction_events(self.db, hash)
            # new block connected or deconnected
            elif label in ["C", "D"]:
                clean_mempool(self.db)
        # schedule ourselves to receive the next message
        asyncio.ensure_future(self.handle())

    def start(self):
        self.loop.add_signal_handler(signal.SIGINT, self.stop)
        self.loop.create_task(self.handle())
        self.loop.run_forever()

    def stop(self):
        self.loop.stop()
        self.zmqContext.destroy()


def run_zmq_handler(args):
    logger.info("Starting Mempool Watcher.")
    sentry.init()
    # Initialise log and config
    server.initialise_log_and_config(argparse.Namespace(**args))
    db = database.get_connection(read_only=False)
    daemon = ZMQHandler(db)
    try:
        daemon.start()
    except KeyboardInterrupt:
        pass
    finally:
        logger.debug("Stopping ZMQ Daemon.")
        daemon.stop()
        db.close()


class MempoolWatcher(object):
    def __init__(self):
        self.process = None

    def start(self, args):
        if self.process is not None:
            raise Exception("Mempool Watcher is already running")
        self.process = Process(target=run_zmq_handler, args=(vars(args),))
        self.process.start()
        return self.process

    def stop(self):
        logger.info("Stopping Mempool Watcher...")
        if self.process and self.process.is_alive():
            self.process.terminate()
        self.process = None
