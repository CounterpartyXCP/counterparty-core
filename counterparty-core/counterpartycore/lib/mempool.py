import logging
import time

from counterpartycore.lib import blocks, config, deserialize, exceptions, ledger, util

logger = logging.getLogger(config.LOGGER_NAME)


def parse_mempool_transactions(db, raw_tx_list):
    util.PARSING_MEMPOOL = True

    logger.debug(f"Parsing {len(raw_tx_list)} raw transactions from mempool...")
    now = time.time()
    transaction_events = []
    cursor = db.cursor()
    try:
        with db:
            # insert fake block
            cursor.execute(
                """INSERT INTO blocks(
                                block_index,
                                block_hash,
                                block_time) VALUES(?,?,?)""",
                (config.MEMPOOL_BLOCK_INDEX, config.MEMPOOL_BLOCK_HASH, now),
            )
            # get the last tx_index
            cursor.execute("SELECT tx_index FROM transactions ORDER BY tx_index DESC LIMIT 1")
            last_tx = cursor.fetchone()
            if last_tx:
                mempool_tx_index = last_tx["tx_index"] + 1
            else:
                mempool_tx_index = 0

            # get message index before parsing the block
            cursor.execute("SELECT MAX(message_index) as message_index FROM messages")
            last_message = cursor.fetchone()
            if last_message:
                message_index_before = last_message["message_index"]
            else:
                message_index_before = -1

            # list_tx
            decoded_tx_count = 0
            for raw_tx in raw_tx_list:
                decoded_tx = deserialize.deserialize_tx(raw_tx, use_txid=True)
                existing_tx = ledger.get_transaction(db, decoded_tx["tx_hash"])
                if existing_tx:
                    logger.trace(f"Transaction {decoded_tx['tx_hash']} already in the database")
                    continue
                existing_tx_in_mempool = cursor.execute(
                    "SELECT * FROM mempool WHERE tx_hash = ? LIMIT 1", (decoded_tx["tx_hash"],)
                ).fetchone()
                if existing_tx_in_mempool:
                    logger.trace(f"Transaction {decoded_tx['tx_hash']} already in the mempool")
                    continue
                mempool_tx_index = blocks.list_tx(
                    db,
                    config.MEMPOOL_BLOCK_HASH,
                    config.MEMPOOL_BLOCK_INDEX,
                    now,
                    decoded_tx["tx_hash"],
                    tx_index=mempool_tx_index,
                    decoded_tx=decoded_tx,
                )
                decoded_tx_count += 1
            logger.trace(f"{decoded_tx_count} transactions inserted from the mempool")

            # parse fake block
            blocks.parse_block(db, config.MEMPOOL_BLOCK_INDEX, now)

            # get messages generated by the transaction
            cursor.execute(
                """SELECT * FROM messages WHERE message_index > ?""",
                (message_index_before,),
            )
            # save the events in memory
            transaction_events = cursor.fetchall()
            # we raise an exception to rollback the transaction
            raise exceptions.MempoolError("Mempool transaction parsed successfully")
    except exceptions.MempoolError:
        # save events in the mempool table
        for event in transaction_events:
            event["timestamp"] = now
            cursor.execute(
                """INSERT INTO mempool VALUES(:tx_hash, :command, :category, :bindings, :timestamp, :event)""",
                event,
            )
    logger.trace("Mempool transaction parsed successfully")
    util.PARSING_MEMPOOL = False


def clean_transaction_events(db, tx_hash):
    cursor = db.cursor()
    cursor.execute("DELETE FROM mempool WHERE tx_hash = ?", (tx_hash,))


def clean_mempool(db):
    logger.debug("Cleaning mempool...")
    cursor = db.cursor()
    cursor.execute("SELECT * FROM mempool")
    mempool_events = cursor.fetchall()
    for event in mempool_events:
        # print(event)
        tx = ledger.get_transaction(db, event["tx_hash"])
        if tx:
            clean_transaction_events(db, event["tx_hash"])
    # delete events older than 24 hours
    cursor.execute(
        "DELETE FROM mempool WHERE timestamp < ?",
        (time.time() - 24 * 60 * 60,),
    )
