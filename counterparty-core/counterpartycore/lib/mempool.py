import json
import logging
import time

from counterpartycore.lib import backend, blocks, config, deserialize, exceptions, ledger, util
from counterpartycore.lib.api.api_watcher import EVENTS_ADDRESS_FIELDS

logger = logging.getLogger(config.LOGGER_NAME)


def parse_mempool_transactions(db, raw_tx_list, timestamps=None):
    util.PARSING_MEMPOOL = True

    logger.trace(f"Parsing {len(raw_tx_list)} raw transaction(s) from the mempool...")
    now = time.time()
    transaction_events = []
    cursor = db.cursor()
    try:
        with db:
            # insert fake block
            cursor.execute(
                """INSERT INTO blocks(
                                block_index,
                                block_hash,
                                block_time) VALUES(?,?,?)""",
                (config.MEMPOOL_BLOCK_INDEX, config.MEMPOOL_BLOCK_HASH, now),
            )
            # get the last tx_index
            cursor.execute("SELECT tx_index FROM transactions ORDER BY tx_index DESC LIMIT 1")
            last_tx = cursor.fetchone()
            if last_tx:
                mempool_tx_index = last_tx["tx_index"] + 1
            else:
                mempool_tx_index = 0

            # get message index before parsing the block
            cursor.execute("SELECT MAX(message_index) as message_index FROM messages")
            last_message = cursor.fetchone()
            if last_message:
                message_index_before = last_message["message_index"]
            else:
                message_index_before = -1

            # list_tx
            decoded_tx_count = 0
            for raw_tx in raw_tx_list:
                decoded_tx = deserialize.deserialize_tx(raw_tx, use_txid=True)
                existing_tx = ledger.get_transaction(db, decoded_tx["tx_hash"])
                if existing_tx:
                    logger.trace(f"Transaction {decoded_tx['tx_hash']} already in the database")
                    continue
                existing_tx_in_mempool = cursor.execute(
                    "SELECT * FROM mempool WHERE tx_hash = ? LIMIT 1", (decoded_tx["tx_hash"],)
                ).fetchone()
                if existing_tx_in_mempool:
                    logger.trace(f"Transaction {decoded_tx['tx_hash']} already in the mempool")
                    continue
                mempool_tx_index = blocks.list_tx(
                    db,
                    config.MEMPOOL_BLOCK_HASH,
                    config.MEMPOOL_BLOCK_INDEX,
                    now,
                    decoded_tx["tx_hash"],
                    tx_index=mempool_tx_index,
                    decoded_tx=decoded_tx,
                )
                decoded_tx_count += 1
            logger.trace(f"{decoded_tx_count} transactions inserted from the mempool")

            # parse fake block
            blocks.parse_block(db, config.MEMPOOL_BLOCK_INDEX, now)

            # get messages generated by the transaction
            cursor.execute(
                """SELECT * FROM messages WHERE message_index > ?""",
                (message_index_before,),
            )
            # save the events in memory
            transaction_events = cursor.fetchall()
            # we raise an exception to rollback the transaction
            raise exceptions.MempoolError("Mempool transaction parsed successfully")
    except exceptions.MempoolError:
        # save events in the mempool table
        for event in transaction_events:
            if timestamps:
                event["timestamp"] = timestamps.get(event["tx_hash"], now)
            else:
                event["timestamp"] = now

            # collect addresses
            addresses = []
            event_bindings = json.loads(event["bindings"])
            if event["event"] in EVENTS_ADDRESS_FIELDS:
                for field in EVENTS_ADDRESS_FIELDS[event["event"]]:
                    if field in event_bindings and event_bindings[field] is not None:
                        addresses.append(event_bindings[field])
            addresses = list(set(addresses))
            event["addresses"] = " ".join(addresses)

            cursor.execute(
                """INSERT INTO mempool VALUES(
                    :tx_hash, :command, :category, :bindings, :timestamp, :event, :addresses
                )""",
                event,
            )
    logger.trace("Mempool transaction parsed successfully")
    util.PARSING_MEMPOOL = False


def clean_transaction_events(db, tx_hash):
    cursor = db.cursor()
    cursor.execute("DELETE FROM mempool WHERE tx_hash = ?", (tx_hash,))


def clean_mempool(db):
    logger.debug("Cleaning mempool...")
    cursor = db.cursor()
    cursor.execute("SELECT * FROM mempool")
    mempool_events = cursor.fetchall()
    for event in mempool_events:
        # print(event)
        tx = ledger.get_transaction(db, event["tx_hash"])
        if tx:
            clean_transaction_events(db, event["tx_hash"])


def parse_raw_mempool(db):
    logger.debug("Parsing raw mempool...")
    raw_mempool = backend.bitcoind.getrawmempool(verbose=True)
    raw_tx_list = []
    timestamps = {}
    cursor = db.cursor()
    for txid, tx_info in raw_mempool.items():
        existing_tx_in_mempool = cursor.execute(
            "SELECT * FROM mempool WHERE tx_hash = ? LIMIT 1", (txid,)
        ).fetchone()
        if existing_tx_in_mempool:
            continue
        try:
            raw_tx = backend.bitcoind.getrawtransaction(txid)
            raw_tx_list.append(raw_tx)
            timestamps[txid] = tx_info["time"]
        except exceptions.BitcoindRPCError as e:
            if "No such mempool or blockchain transaction" in str(e):
                pass
            else:
                raise e
    parse_mempool_transactions(db, raw_tx_list, timestamps)
