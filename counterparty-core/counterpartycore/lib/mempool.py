import logging
import time

from counterpartycore.lib import blocks, config, deserialize, exceptions, ledger

logger = logging.getLogger(config.LOGGER_NAME)

PARSING_MEMPOOL = False


def parse_mempool_transactions(db, raw_tx_list):
    global PARSING_MEMPOOL  # noqa
    PARSING_MEMPOOL = True

    logger.debug(f"Parsing {len(raw_tx_list)} raw transactions from mempool...")
    now = time.time()
    transaction_events = []
    cursor = db.cursor()
    try:
        with db:
            # insert fake block
            cursor.execute(
                """INSERT INTO blocks(
                                block_index,
                                block_hash,
                                block_time) VALUES(?,?,?)""",
                (config.MEMPOOL_BLOCK_INDEX, config.MEMPOOL_BLOCK_HASH, now),
            )
            # get the last tx_index
            cursor.execute("SELECT tx_index FROM transactions ORDER BY tx_index DESC LIMIT 1")
            mempool_tx_index = cursor.fetchone()["tx_index"] + 1
            # list_tx
            for raw_tx in raw_tx_list:
                decoded_tx = deserialize.deserialize_tx(raw_tx, use_txid=True)
                logger.trace(f"Decoded transaction: {decoded_tx['tx_hash']}")
                mempool_tx_index = blocks.list_tx(
                    db,
                    config.MEMPOOL_BLOCK_HASH,
                    config.MEMPOOL_BLOCK_INDEX,
                    now,
                    decoded_tx["tx_hash"],
                    tx_index=mempool_tx_index,
                    decoded_tx=decoded_tx,
                )
            # get message index before parsing the block
            cursor.execute("SELECT MAX(message_index) as message_index FROM messages")
            message_index_before = cursor.fetchone()["message_index"]
            # parse fake block
            blocks.parse_block(db, config.MEMPOOL_BLOCK_INDEX, now)
            # get messages generated by the transaction
            cursor.execute(
                """SELECT * FROM messages WHERE message_index > ?""",
                (message_index_before,),
            )
            # save the events in memory
            transaction_events = cursor.fetchall()
            # we raise an exception to rollback the transaction
            raise exceptions.MempoolError("Mempool transaction parsed successfully")
    except exceptions.MempoolError:
        # save events in the mempool table
        for event in transaction_events:
            cursor.execute(
                """INSERT INTO mempool VALUES(:tx_hash, :command, :category, :bindings, :timestamp, :event)""",
                event,
            )
    logger.trace("Mempool transaction parsed successfully")
    PARSING_MEMPOOL = False


def clean_transaction_events(db, tx_hash):
    cursor = db.cursor()
    cursor.execute("DELETE FROM mempool WHERE tx_hash = ?", (tx_hash,))


def clean_mempool(db):
    logger.debug("Cleaning mempool...")
    cursor = db.cursor()
    cursor.execute("SELECT * FROM mempool")
    mempool_events = cursor.fetchall()
    for event in mempool_events:
        tx = ledger.get_transaction(db, event["tx_hash"])
        if tx:
            clean_transaction_events(db, event["tx_hash"])
